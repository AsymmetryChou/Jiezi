# Copyright 2021 Jiezi authors.
#
# This file is part of Jiezi. It is subject to the license terms in the file
# LICENSE.md found in the top-level directory of this distribution. A list of
# Jiezi authors can be found in the file AUTHORS.md at the top-level directory
# of this distribution.
# ==============================================================================
import numpy as np
import math


def fermiIntegral(eta, j = -1/2, Nmax = 1000, tol = 1e-3):
    if eta > 15:
        eta = 15
    y_old = 0
    for N in range(1, Nmax + 1):
        a = -4.5
        b = 5.0
        t = np.linspace(a, b, N + 1)
        x = np.exp(t - np.exp(-t))
        f = x * (1 + np.exp(-t)) * x ** j / (1 + np.exp( x - eta))
        y = np.trapz(f, dx=t[1]-t[0])
        if N > 1:
            err = abs(y - y_old)
            if err < tol:
                break
        y_old = y
    if N == Nmax:
        print('error: Fermi Integral increase the maximum number of iterations.')
    # y = y / math.gamma(j + 1)
    return y

def inverseFermiIntegral(u):
    if 0 < u < u_n[0]:
        res = np.log(u * Rfunc(u, 0))
    for i in range(4):
        if u_n[i] <= u < u_n[i + 1]:
            res = Rfunc(u, i + 1)
            break
    if u >= u_n[4]:
        res = np.sqrt(Rfunc(25798.742392161875614/(u ** 4), 5))
    return res

def DerivativeFermiIntegral(eta):
    delta = 1e-7
    res = (fermiIntegral(eta + delta) - fermiIntegral(eta)) / delta
    return res

u_n = [2.3441053212124923635, 3.8475810464125087923, 5.6270896934467898338,
       8.0747714790662749546, 12.670348407162363013]
eta_n = [1.6674890518188476563, 3.9510517120361328125, 8.0275478363037109375,
         16.351613998413085938, 40.154967308044433594]
P_n = [[4.1455867063620057963E+3, 4.6492489228825891548E+3, 2.5468279472604635596E+3, 8.2617183361519822852E+2,
        1.6523324342898456833E+2, 1.9139098333899331728E+1, 1.0000233523167968436, 0],
       [1.0005640037689060269E+5, 9.3795876901690924263E+4, 1.1968436775807236253E+4, 3.6056056623169881285E+3,
        3.0032390254773869879E+3, 2.0666293152698467755E+2, 4.6967188364979637811E+1, 1.2655799929098327278E+1],
       [7.8077080328620324941E+5, 7.4511980207693273717E+5, 4.8570139135090628839E+5, 2.1012609976203759489E+5,
        6.5930590125900094802E+4, 1.6082333682678120185E+4, 2.3070507238486040474E+3, 2.1459577052537728303E+2],
       [9.723633697100386227E+7, 1.0164545252921651718E+8, 5.610803657489166187E+7, 2.0533262113418584594E+7,
        5.262211474540097266E+6, 9.659593698445202991E+5, 1.1215569374855787353E+5, 6.002807590319266831E+3],
       [9.859217899528706965E+10, 9.212482052867463736E+10, 4.659030699733763790E+10, 1.500219539387355430E+10,
        3.429550982788585142E+9, 5.388776274849922981E+8, 4.856263306490216609E+7, 1.797949664146387803E+6],
       [1.5170328199539480859E+6, 1.7902383580145112376E+5, 2.9240858775000640610E+3, 1, 0, 0, 0, 0]]

Q_n = [[1.8339260939384764384E+3, 3.6590141066361902419E+3, 3.3125828231919297460E+3, 1.7661058946629507641E+3,
        5.9995878325365685481E+2, 1.3022439202514782925E+2, 1.6795762274957634668E+1, 1],
       [6.0004232272321102537E+4, 9.4591460433134797911E+3, -3.0260143411431122729E+3, 2.2053261399494976502E+3,
        1.6664644949295151752E+2, -6.1135903669333744537E+1, 1.7137481288783257727E+1, -1],
       [1.9761087937870631931E+5, 9.7473867500546756247E+4, 6.5697985373221757818E+4, 1.5810815030487697013E+4,
        5.1437064634502537530E+3, 5.4591421450702277492E+2, 2.5466648701491294769E+1, -1],
       [1.2112831832812397277E+7, 8.485660688557204553E+6, 3.6641826655801482580E+6, 1.0199175729180822690E+6,
        1.8645751101280014065E+5, 2.3351572064362269016E+4, 2.3351572064362269016E+4, -1],
       [6.029507485001503472E+9, 4.1500445650217712266E+9, 1.7347612878358778140E+9, 4.2659950096560926778E+8,
        7.803780012911421033E+7, 7.194457928823351679E+6, -7.194457928823351679E+6, 1],
       [9.398803527483198144E+2, 1.1187685020374838766E+2, 1.9239024822840602874, 2.3436621932409201918E-3, 0, 0, 0, 0]]

def Rfunc(u, index):
    y_list = [u_n[0] - u, u - u_n[0], u - u_n[1], u - u_n[2],
              u - u_n[3], 1 - u]
    a = 0
    b = 0
    for j in range(8):
        a += P_n[index][j] * y_list[index] ** j
        b += Q_n[index][j] * y_list[index] ** j
    res = a / b
    return res
